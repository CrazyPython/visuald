<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>std.windows.registry</title>
        </head><body>
        <h1>std.windows.registry</h1>
        <!-- Generated by Ddoc from std\windows\registry.d -->
This library provides Win32 Registry facilities.
<br><br>
<b>License:</b><br>
<br><br>
<b>Author:</b><br>
Matthew Wilson, Kenji Hara

<br><br>
<b>Histry:</b><br>
Created      15th March 2003,
        Updated      25th April 2004,

<br><br>
<b>Source:</b><br>
<br><br>

<dl><dt><big><a name="Win32Exception"></a>class <u>Win32Exception</u>: object.Exception;
</big></dt>
<dd>
</dd>
<dt><big><a name="RegistryException"></a>class <u>RegistryException</u>: std.windows.registry.Win32Exception;
</big></dt>
<dd>Exception class thrown by the std.windows.registry classes.<br><br>

<dl><dt><big><a name="RegistryException.this"></a> this(string <i>message</i>, string <i>fn</i> = __FILE__, size_t <i>ln</i> = __LINE__, Throwable <i>next</i> = null);
</big></dt>
<dd>Creates an instance of the exception.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>message</i></td>
<td>The <i>message</i> associated with the exception.</td></tr>
</table><br>

</dd>
<dt><big><a name="RegistryException.this"></a> this(string <i>message</i>, int <i>error</i>, string <i>fn</i> = __FILE__, size_t <i>ln</i> = __LINE__, Throwable <i>next</i> = null);
</big></dt>
<dd>Creates an instance of the exception, with the given.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>message</i></td>
<td>The <i>message</i> associated with the exception.</td></tr>
<tr><td>int <i>error</i></td>
<td>The Win32 <i>error</i> number associated with the exception.</td></tr>
</table><br>

</dd>
</dl>
</dd>
<dt><big><a name="REGSAM"></a>enum <u>REGSAM</u>: int;
</big></dt>
<dd>Enumeration of the recognised registry access modes.<br><br>

<dl><dt><big><a name="REGSAM.KEY_QUERY_VALUE"></a><u>KEY_QUERY_VALUE</u></big></dt>
<dd>Permission to query subkey data<br><br>

</dd>
<dt><big><a name="REGSAM.KEY_SET_VALUE"></a><u>KEY_SET_VALUE</u></big></dt>
<dd>Permission to set subkey data<br><br>

</dd>
<dt><big><a name="REGSAM.KEY_CREATE_SUB_KEY"></a><u>KEY_CREATE_SUB_KEY</u></big></dt>
<dd>Permission to create subkeys<br><br>

</dd>
<dt><big><a name="REGSAM.KEY_ENUMERATE_SUB_KEYS"></a><u>KEY_ENUMERATE_SUB_KEYS</u></big></dt>
<dd>Permission to enumerate subkeys<br><br>

</dd>
<dt><big><a name="REGSAM.KEY_NOTIFY"></a><u>KEY_NOTIFY</u></big></dt>
<dd>Permission for change notification<br><br>

</dd>
<dt><big><a name="REGSAM.KEY_CREATE_LINK"></a><u>KEY_CREATE_LINK</u></big></dt>
<dd>Permission to create a symbolic link<br><br>

</dd>
<dt><big><a name="REGSAM.KEY_WOW64_32KEY"></a><u>KEY_WOW64_32KEY</u></big></dt>
<dd>Enables a 64- or 32-bit application to open a 32-bit key<br><br>

</dd>
<dt><big><a name="REGSAM.KEY_WOW64_64KEY"></a><u>KEY_WOW64_64KEY</u></big></dt>
<dd>Enables a 64- or 32-bit application to open a 64-bit key<br><br>

</dd>
<dt><big><a name="REGSAM.KEY_WOW64_RES"></a><u>KEY_WOW64_RES</u></big></dt>
<dd><br><br>
</dd>
<dt><big><a name="REGSAM.KEY_WRITE"></a><u>KEY_WRITE</u></big></dt>
<dd>Combines the STANDARD_RIGHTS_READ, KEY_QUERY_VALUE,
 KEY_ENUMERATE_SUB_KEYS, and KEY_NOTIFY access rights<br><br>

</dd>
<dt><big><a name="REGSAM.KEY_EXECUTE"></a><u>KEY_EXECUTE</u></big></dt>
<dd>Combines the STANDARD_RIGHTS_WRITE, KEY_SET_VALUE,
 and KEY_CREATE_SUB_KEY access rights<br><br>

</dd>
<dt><big><a name="REGSAM.KEY_ALL_ACCESS"></a><u>KEY_ALL_ACCESS</u></big></dt>
<dd>Permission for read access<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="REG_VALUE_TYPE"></a>enum <u>REG_VALUE_TYPE</u>: uint;
</big></dt>
<dd>Enumeration of the recognised registry value types.<br><br>

<dl><dt><big><a name="REG_VALUE_TYPE.REG_UNKNOWN"></a><u>REG_UNKNOWN</u></big></dt>
<dd><br><br>
</dd>
<dt><big><a name="REG_VALUE_TYPE.REG_NONE"></a><u>REG_NONE</u></big></dt>
<dd>The <b>null</b> value type. (In practise this is treated as a zero-length binary array by the Win32 registry)<br><br>

</dd>
<dt><big><a name="REG_VALUE_TYPE.REG_SZ"></a><u>REG_SZ</u></big></dt>
<dd>A zero-terminated string<br><br>

</dd>
<dt><big><a name="REG_VALUE_TYPE.REG_EXPAND_SZ"></a><u>REG_EXPAND_SZ</u></big></dt>
<dd>A zero-terminated string containing expandable environment variable references<br><br>

</dd>
<dt><big><a name="REG_VALUE_TYPE.REG_BINARY"></a><u>REG_BINARY</u></big></dt>
<dd>A binary blob<br><br>

</dd>
<dt><big><a name="REG_VALUE_TYPE.REG_DWORD"></a><u>REG_DWORD</u></big></dt>
<dd>A 32-bit unsigned integer<br><br>

</dd>
<dt><big><a name="REG_VALUE_TYPE.REG_DWORD_LITTLE_ENDIAN"></a><u>REG_DWORD_LITTLE_ENDIAN</u></big></dt>
<dd>A 32-bit unsigned integer, stored in little-endian byte order<br><br>

</dd>
<dt><big><a name="REG_VALUE_TYPE.REG_DWORD_BIG_ENDIAN"></a><u>REG_DWORD_BIG_ENDIAN</u></big></dt>
<dd>A 32-bit unsigned integer, stored in big-endian byte order<br><br>

</dd>
<dt><big><a name="REG_VALUE_TYPE.REG_LINK"></a><u>REG_LINK</u></big></dt>
<dd>A registry link<br><br>

</dd>
<dt><big><a name="REG_VALUE_TYPE.REG_MULTI_SZ"></a><u>REG_MULTI_SZ</u></big></dt>
<dd>A set of zero-terminated strings<br><br>

</dd>
<dt><big><a name="REG_VALUE_TYPE.REG_RESOURCE_LIST"></a><u>REG_RESOURCE_LIST</u></big></dt>
<dd>A hardware resource list<br><br>

</dd>
<dt><big><a name="REG_VALUE_TYPE.REG_FULL_RESOURCE_DESCRIPTOR"></a><u>REG_FULL_RESOURCE_DESCRIPTOR</u></big></dt>
<dd>A hardware resource descriptor<br><br>

</dd>
<dt><big><a name="REG_VALUE_TYPE.REG_RESOURCE_REQUIREMENTS_LIST"></a><u>REG_RESOURCE_REQUIREMENTS_LIST</u></big></dt>
<dd>A hardware resource requirements list<br><br>

</dd>
<dt><big><a name="REG_VALUE_TYPE.REG_QWORD"></a><u>REG_QWORD</u></big></dt>
<dd>A 64-bit unsigned integer<br><br>

</dd>
<dt><big><a name="REG_VALUE_TYPE.REG_QWORD_LITTLE_ENDIAN"></a><u>REG_QWORD_LITTLE_ENDIAN</u></big></dt>
<dd>A 64-bit unsigned integer, stored in little-endian byte order<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Key"></a>class <u>Key</u>;
</big></dt>
<dd>This class represents a registry key.<br><br>

<dl><dt><big><a name="Key.name"></a>const pure nothrow @property @safe string <u>name</u>();
</big></dt>
<dd>The <u>name</u> of the key<br><br>

</dd>
<dt><big><a name="Key.keyCount"></a>const @property size_t <u>keyCount</u>();
</big></dt>
<dd>The number of sub keys.<br><br>

</dd>
<dt><big><a name="Key.keys"></a>pure @property @safe KeySequence <u>keys</u>();
</big></dt>
<dd>An enumerable sequence of all the sub-<u>keys</u> of this key.<br><br>

</dd>
<dt><big><a name="Key.keyNames"></a>pure @property @safe KeyNameSequence <u>keyNames</u>();
</big></dt>
<dd>An enumerable sequence of the names of all the sub-keys of this key.<br><br>

</dd>
<dt><big><a name="Key.valueCount"></a>const @property size_t <u>valueCount</u>();
</big></dt>
<dd>The number of values.<br><br>

</dd>
<dt><big><a name="Key.values"></a>pure @property @safe ValueSequence <u>values</u>();
</big></dt>
<dd>An enumerable sequence of all the <u>values</u> of this key.<br><br>

</dd>
<dt><big><a name="Key.valueNames"></a>pure @property @safe ValueNameSequence <u>valueNames</u>();
</big></dt>
<dd>An enumerable sequence of the names of all the values of this key.<br><br>

</dd>
<dt><big><a name="Key.createKey"></a>Key <u>createKey</u>(string <i>name</i>, REGSAM <i>access</i> = REGSAM.KEY_ALL_ACCESS);
</big></dt>
<dd>Returns the named sub-key of this key.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the subkey to create. May not be .</td></tr>
</table><br>
<b>Returns:</b><br>
The created key.
<br><br>
<b>Throws:</b><br>
 is thrown if the key cannot be created.<br><br>

</dd>
<dt><big><a name="Key.getKey"></a>Key <u>getKey</u>(string <i>name</i>, REGSAM <i>access</i> = REGSAM.KEY_READ);
</big></dt>
<dd>Returns the named sub-key of this key.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the subkey to aquire. If <i>name</i> is the empty
                   string, then the called key is duplicated.</td></tr>
<tr><td>REGSAM <i>access</i></td>
<td>The desired <i>access</i>; one of the  enumeration.</td></tr>
</table><br>
<b>Returns:</b><br>
The aquired key.
<br><br>
<b>Throws:</b><br>
This function never returns . If a key corresponding to
            the requested <i>name</i> is not found,  is thrown.<br><br>

</dd>
<dt><big><a name="Key.deleteKey"></a>void <u>deleteKey</u>(string <i>name</i>, REGSAM <i>access</i> = cast(REGSAM)0);
</big></dt>
<dd>Deletes the named key.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the key to delete. May not be .</td></tr>
</table><br>

</dd>
<dt><big><a name="Key.getValue"></a>Value <u>getValue</u>(string <i>name</i>);
</big></dt>
<dd>Returns the named value.
        If  is the empty string, then the default value is returned.
<br><br>
<b>Returns:</b><br>
This function never returns . If a value corresponding
            to the requested <i>name</i> is not found,  is thrown.<br><br>

</dd>
<dt><big><a name="Key.setValue"></a>void <u>setValue</u>(string <i>name</i>, uint <i>value</i>);
</big></dt>
<dd>Sets the named <i>value</i> with the given 32-bit unsigned integer <i>value</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the <i>value</i> to set. If it is the empty string,
                   sets the default <i>value</i>.</td></tr>
<tr><td>uint <i>value</i></td>
<td>The 32-bit unsigned <i>value</i> to set.</td></tr>
</table><br>
<b>Throws:</b><br>
If a <i>value</i> corresponding to the requested <i>name</i> is not found,
             is thrown.<br><br>

</dd>
<dt><big><a name="Key.setValue"></a>void <u>setValue</u>(string <i>name</i>, uint <i>value</i>, Endian <i>endian</i>);
</big></dt>
<dd>Sets the named <i>value</i> with the given 32-bit unsigned integer <i>value</i>,
        according to the desired byte-ordering.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the <i>value</i> to set. If it is the empty string,
                   sets the default <i>value</i>.</td></tr>
<tr><td>uint <i>value</i></td>
<td>The 32-bit unsigned <i>value</i> to set.</td></tr>
<tr><td>Endian <i>endian</i></td>
<td>Can be  or .</td></tr>
</table><br>
<b>Throws:</b><br>
If a <i>value</i> corresponding to the requested <i>name</i> is not found,
             is thrown.<br><br>

</dd>
<dt><big><a name="Key.setValue"></a>void <u>setValue</u>(string <i>name</i>, ulong <i>value</i>);
</big></dt>
<dd>Sets the named <i>value</i> with the given 64-bit unsigned integer <i>value</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the <i>value</i> to set. If it is the empty string,
                   sets the default <i>value</i>.</td></tr>
<tr><td>ulong <i>value</i></td>
<td>The 64-bit unsigned <i>value</i> to set.</td></tr>
</table><br>
<b>Throws:</b><br>
If a <i>value</i> corresponding to the requested <i>name</i> is not found,
             is thrown.<br><br>

</dd>
<dt><big><a name="Key.setValue"></a>void <u>setValue</u>(string <i>name</i>, string <i>value</i>);
</big></dt>
<dd>Sets the named <i>value</i> with the given string <i>value</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the <i>value</i> to set. If it is the empty string,
                   sets the default <i>value</i>.</td></tr>
<tr><td>string <i>value</i></td>
<td>The string <i>value</i> to set.</td></tr>
</table><br>
<b>Throws:</b><br>
If a <i>value</i> corresponding to the requested <i>name</i> is not found,
             is thrown.<br><br>

</dd>
<dt><big><a name="Key.setValue"></a>void <u>setValue</u>(string <i>name</i>, string <i>value</i>, bool <i>asEXPAND_SZ</i>);
</big></dt>
<dd>Sets the named <i>value</i> with the given string <i>value</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the <i>value</i> to set. If it is the empty string,
                   sets the default <i>value</i>.</td></tr>
<tr><td>string <i>value</i></td>
<td>The string <i>value</i> to set.</td></tr>
<tr><td>bool <i>asEXPAND_SZ</i></td>
<td>If , the <i>value</i> will be stored as an
                          expandable environment string, otherwise as a normal string.</td></tr>
</table><br>
<b>Throws:</b><br>
If a <i>value</i> corresponding to the requested <i>name</i> is not found,
             is thrown.<br><br>

</dd>
<dt><big><a name="Key.setValue"></a>void <u>setValue</u>(string <i>name</i>, string[] <i>value</i>);
</big></dt>
<dd>Sets the named <i>value</i> with the given multiple-strings <i>value</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the <i>value</i> to set. If it is the empty string,
                   sets the default <i>value</i>.</td></tr>
<tr><td>string[] <i>value</i></td>
<td>The multiple-strings <i>value</i> to set.</td></tr>
</table><br>
<b>Throws:</b><br>
If a <i>value</i> corresponding to the requested <i>name</i> is not found,
             is thrown.<br><br>

</dd>
<dt><big><a name="Key.setValue"></a>void <u>setValue</u>(string <i>name</i>, byte[] <i>value</i>);
</big></dt>
<dd>Sets the named <i>value</i> with the given binary <i>value</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the <i>value</i> to set. If it is the empty string,
                   sets the default <i>value</i>.</td></tr>
<tr><td>byte[] <i>value</i></td>
<td>The binary <i>value</i> to set.</td></tr>
</table><br>
<b>Throws:</b><br>
If a <i>value</i> corresponding to the requested <i>name</i> is not found,
             is thrown.<br><br>

</dd>
<dt><big><a name="Key.deleteValue"></a>void <u>deleteValue</u>(string <i>name</i>);
</big></dt>
<dd>Deletes the named value.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name</i></td>
<td>The <i>name</i> of the value to delete. May not be .</td></tr>
</table><br>
<b>Throws:</b><br>
If a value of the requested <i>name</i> is not found,
             is thrown.<br><br>

</dd>
<dt><big><a name="Key.flush"></a>void <u>flush</u>();
</big></dt>
<dd>Flushes any changes to the key to disk.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Value"></a>class <u>Value</u>;
</big></dt>
<dd>This class represents a value of a registry key.<br><br>

<dl><dt><big><a name="Value.name"></a>const pure nothrow @property @safe string <u>name</u>();
</big></dt>
<dd>The <u>name</u> of the value.
        If the value represents a default value of a key, which has no <u>name</u>,
        the returned string will be of zero length.<br><br>

</dd>
<dt><big><a name="Value.type"></a>const pure nothrow @property @safe REG_VALUE_TYPE <u>type</u>();
</big></dt>
<dd>The <u>type</u> of value.<br><br>

</dd>
<dt><big><a name="Value.value_SZ"></a>const @property string <u>value_SZ</u>();
</big></dt>
<dd>Obtains the current value of the value as a string.
        If the value's type is REG_EXPAND_SZ the returned value is <b>not</b>
        expanded;  should be called
<br><br>
<b>Returns:</b><br>
The contents of the value.
<br><br>
<b>Throws:</b><br>
 if the type of the value is not REG_SZ,
            REG_EXPAND_SZ, REG_DWORD, or REG_QWORD.<br><br>

</dd>
<dt><big><a name="Value.value_EXPAND_SZ"></a>const @property string <u>value_EXPAND_SZ</u>();
</big></dt>
<dd>Obtains the current value as a string, within which any environment
        variables have undergone expansion.
        This function works with the same value-types as .
<br><br>
<b>Returns:</b><br>
The contents of the value.<br><br>

</dd>
<dt><big><a name="Value.value_MULTI_SZ"></a>const @property string[] <u>value_MULTI_SZ</u>();
</big></dt>
<dd>Obtains the current value as an array of strings.
<br><br>
<b>Returns:</b><br>
The contents of the value.
<br><br>
<b>Throws:</b><br>
 if the type of the value is not REG_MULTI_SZ.<br><br>

</dd>
<dt><big><a name="Value.value_DWORD"></a>const @property uint <u>value_DWORD</u>();
</big></dt>
<dd>Obtains the current value as a 32-bit unsigned integer, ordered
        correctly according to the current architecture.
<br><br>
<b>Returns:</b><br>
The contents of the value.
<br><br>
<b>Throws:</b><br>
 is thrown for all types other than
            REG_DWORD, REG_DWORD_LITTLE_ENDIAN and REG_DWORD_BIG_ENDIAN.<br><br>

</dd>
<dt><big><a name="Value.value_QWORD"></a>const @property ulong <u>value_QWORD</u>();
</big></dt>
<dd>Obtains the value as a 64-bit unsigned integer, ordered correctly
        according to the current architecture.
<br><br>
<b>Returns:</b><br>
The contents of the value.
<br><br>
<b>Throws:</b><br>
 if the type of the value is not REG_QWORD.<br><br>

</dd>
<dt><big><a name="Value.value_BINARY"></a>const @property byte[] <u>value_BINARY</u>();
</big></dt>
<dd>Obtains the value as a binary blob.
<br><br>
<b>Returns:</b><br>
The contents of the value.
<br><br>
<b>Throws:</b><br>
 if the type of the value is not REG_BINARY.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Registry"></a>class <u>Registry</u>;
</big></dt>
<dd>Represents the local system registry.<br><br>

<dl><dt><big><a name="Registry.classesRoot"></a>static @property Key <u>classesRoot</u>();
</big></dt>
<dd>Returns the root key for the HKEY_CLASSES_ROOT hive<br><br>

</dd>
<dt><big><a name="Registry.currentUser"></a>static @property Key <u>currentUser</u>();
</big></dt>
<dd>Returns the root key for the HKEY_CURRENT_USER hive<br><br>

</dd>
<dt><big><a name="Registry.localMachine"></a>static @property Key <u>localMachine</u>();
</big></dt>
<dd>Returns the root key for the HKEY_LOCAL_MACHINE hive<br><br>

</dd>
<dt><big><a name="Registry.users"></a>static @property Key <u>users</u>();
</big></dt>
<dd>Returns the root key for the HKEY_USERS hive<br><br>

</dd>
<dt><big><a name="Registry.performanceData"></a>static @property Key <u>performanceData</u>();
</big></dt>
<dd>Returns the root key for the HKEY_PERFORMANCE_DATA hive<br><br>

</dd>
<dt><big><a name="Registry.currentConfig"></a>static @property Key <u>currentConfig</u>();
</big></dt>
<dd>Returns the root key for the HKEY_CURRENT_CONFIG hive<br><br>

</dd>
<dt><big><a name="Registry.dynData"></a>static @property Key <u>dynData</u>();
</big></dt>
<dd>Returns the root key for the HKEY_DYN_DATA hive<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="KeyNameSequence"></a>class <u>KeyNameSequence</u>;
</big></dt>
<dd>An enumerable sequence representing the names of the sub-keys of a registry Key.
<br><br>
<b>Example:</b><br>
<pre class="d_code">Key key = ...
<font color=blue>foreach</font> (string subkeyName; key.keyNames)
{
    <font color=green>// using subkeyName
</font>}
</pre>
<br><br>

<dl><dt><big><a name="KeyNameSequence.count"></a>const @property size_t <u>count</u>();
</big></dt>
<dd>The number of keys.<br><br>

</dd>
<dt><big><a name="KeyNameSequence.getKeyName"></a>string <u>getKeyName</u>(size_t <i>index</i>);
</big></dt>
<dd>The name of the key at the given <i>index</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>index</i></td>
<td>The 0-based <i>index</i> of the key to retrieve.</td></tr>
</table><br>
<b>Returns:</b><br>
The name of the key corresponding to the given <i>index</i>.
<br><br>
<b>Throws:</b><br>
RegistryException if no corresponding key is retrieved.<br><br>

</dd>
<dt><big><a name="KeyNameSequence.opIndex"></a>string <u>opIndex</u>(size_t <i>index</i>);
</big></dt>
<dd>The name of the key at the given <i>index</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>index</i></td>
<td>The 0-based <i>index</i> of the key to retrieve.</td></tr>
</table><br>
<b>Returns:</b><br>
The name of the key corresponding to the given <i>index</i>.
<br><br>
<b>Throws:</b><br>
 if no corresponding key is retrieved.<br><br>

</dd>
<dt><big><a name="KeyNameSequence.opApply"></a>int <u>opApply</u>(scope int delegate(ref string name) <i>dg</i>);
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="KeySequence"></a>class <u>KeySequence</u>;
</big></dt>
<dd>An enumerable sequence representing the sub-keys of a registry Key.
<br><br>
<b>Example:</b><br>
<pre class="d_code">Key key = ...
<font color=blue>foreach</font> (Key subkey; key.keys)
{
    <font color=green>// using subkey
</font>}
</pre>
<br><br>

<dl><dt><big><a name="KeySequence.count"></a>const @property size_t <u>count</u>();
</big></dt>
<dd>The number of keys.<br><br>

</dd>
<dt><big><a name="KeySequence.getKey"></a>Key <u>getKey</u>(size_t <i>index</i>);
</big></dt>
<dd>The key at the given <i>index</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>index</i></td>
<td>The 0-based <i>index</i> of the key to retrieve.</td></tr>
</table><br>
<b>Returns:</b><br>
The key corresponding to the given <i>index</i>.
<br><br>
<b>Throws:</b><br>
 if no corresponding key is retrieved.<br><br>

</dd>
<dt><big><a name="KeySequence.opIndex"></a>Key <u>opIndex</u>(size_t <i>index</i>);
</big></dt>
<dd>The key at the given <i>index</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>index</i></td>
<td>The 0-based <i>index</i> of the key to retrieve.</td></tr>
</table><br>
<b>Returns:</b><br>
The key corresponding to the given <i>index</i>.
<br><br>
<b>Throws:</b><br>
 if no corresponding key is retrieved.<br><br>

</dd>
<dt><big><a name="KeySequence.opApply"></a>int <u>opApply</u>(scope int delegate(ref Key key) <i>dg</i>);
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="ValueNameSequence"></a>class <u>ValueNameSequence</u>;
</big></dt>
<dd>An enumerable sequence representing the names of the values of a registry Key.
<br><br>
<b>Example:</b><br>
<pre class="d_code">Key key = ...
<font color=blue>foreach</font> (string valueName; key.valueNames)
{
    <font color=green>// using valueName
</font>}
</pre>
<br><br>

<dl><dt><big><a name="ValueNameSequence.count"></a>const @property size_t <u>count</u>();
</big></dt>
<dd>The number of values.<br><br>

</dd>
<dt><big><a name="ValueNameSequence.getValueName"></a>string <u>getValueName</u>(size_t <i>index</i>);
</big></dt>
<dd>The name of the value at the given <i>index</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>index</i></td>
<td>The 0-based <i>index</i> of the value to retrieve.</td></tr>
</table><br>
<b>Returns:</b><br>
The name of the value corresponding to the given <i>index</i>.
<br><br>
<b>Throws:</b><br>
 if no corresponding value is retrieved.<br><br>

</dd>
<dt><big><a name="ValueNameSequence.opIndex"></a>string <u>opIndex</u>(size_t <i>index</i>);
</big></dt>
<dd>The name of the value at the given <i>index</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>index</i></td>
<td>The 0-based <i>index</i> of the value to retrieve.</td></tr>
</table><br>
<b>Returns:</b><br>
The name of the value corresponding to the given <i>index</i>.
<br><br>
<b>Throws:</b><br>
 if no corresponding value is retrieved.<br><br>

</dd>
<dt><big><a name="ValueNameSequence.opApply"></a>int <u>opApply</u>(scope int delegate(ref string name) <i>dg</i>);
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="ValueSequence"></a>class <u>ValueSequence</u>;
</big></dt>
<dd>An enumerable sequence representing the values of a registry Key.
<br><br>
<b>Example:</b><br>
<pre class="d_code">Key key = ...
<font color=blue>foreach</font> (Value value; key.values)
{
    <font color=green>// using value
</font>}
</pre>
<br><br>

<dl><dt><big><a name="ValueSequence.count"></a>const @property size_t <u>count</u>();
</big></dt>
<dd>The number of values<br><br>

</dd>
<dt><big><a name="ValueSequence.getValue"></a>Value <u>getValue</u>(size_t <i>index</i>);
</big></dt>
<dd>The value at the given .
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>index</i></td>
<td>The 0-based <i>index</i> of the value to retrieve</td></tr>
</table><br>
<b>Returns:</b><br>
The value corresponding to the given <i>index</i>.
<br><br>
<b>Throws:</b><br>
 if no corresponding value is retrieved<br><br>

</dd>
<dt><big><a name="ValueSequence.opIndex"></a>Value <u>opIndex</u>(size_t <i>index</i>);
</big></dt>
<dd>The value at the given .
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>index</i></td>
<td>The 0-based <i>index</i> of the value to retrieve.</td></tr>
</table><br>
<b>Returns:</b><br>
The value corresponding to the given <i>index</i>.
<br><br>
<b>Throws:</b><br>
 if no corresponding value is retrieved.<br><br>

</dd>
<dt><big><a name="ValueSequence.opApply"></a>int <u>opApply</u>(scope int delegate(ref Value value) <i>dg</i>);
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright 2003-2004 by Matthew Wilson and Synesis Software
               Written by Matthew Wilson

</small>
        </body></html>
